#!/usr/bin/env -S deno run -A

// Syncs Claude Code configuration to Codex CLI and Gemini CLI.
// Claude Code is the single source of truth.
//
// Usage:
//   deno task sync                # Sync all
//   deno task sync instructions   # CLAUDE.md + rules -> AGENTS.md / GEMINI.md
//   deno task sync skills         # Verify/create skill symlinks
//   deno task sync mcp            # mcp.json -> config.toml / settings.json
//   deno task sync commands       # commands/*.md -> commands/*.toml (Gemini)
//   deno task sync --check        # Verify sync state without changes

import { dirname, fromFileUrl, join } from "@std/path";

const root = fromFileUrl(new URL("../", import.meta.url));
const home = {
  claude: join(root, "home", "claude"),
  codex: join(root, "home", "codex"),
  gemini: join(root, "home", "gemini"),
};

const GENERATED_MD = [
  "<!-- AUTO-GENERATED by .scripts/sync-tools.ts from home/claude/ -->",
  "<!-- Do not edit directly. Run: deno task sync -->",
].join("\n");

const GENERATED_TOML = [
  "# AUTO-GENERATED by .scripts/sync-tools.ts from home/claude/",
  "# Do not edit directly. Run: deno task sync",
].join("\n");

// Common rules to embed in AGENTS.md / GEMINI.md (not Claude-specific)
const SHARED_RULES = [
  "git/safety.md",
  "git/commit-safety.md",
  "tools/github-issue-type.md",
];

// Skills to symlink from claude -> codex/gemini
const SHARED_SKILLS = ["deno", "ts", "rust"];

// Claude commands to convert to Gemini TOML
const COMMANDS_TO_CONVERT = [
  "resync",
  "git/commit",
  "git/commit-staged",
  "git/branch",
  "pr/create",
];

// ============================================================
// Utilities
// ============================================================

async function readText(path: string): Promise<string> {
  return Deno.readTextFile(path);
}

async function writeIfChanged(
  path: string,
  content: string,
  check: boolean,
): Promise<boolean> {
  await Deno.mkdir(dirname(path), { recursive: true });

  try {
    const existing = await readText(path);
    if (existing === content) return true; // already up to date
  } catch {
    // file doesn't exist
  }

  if (check) return false; // out of date or missing

  await Deno.writeTextFile(path, content);
  return true;
}

function parseFrontmatter(
  content: string,
): { meta: Record<string, string>; body: string } {
  const m = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
  if (!m) return { meta: {}, body: content };

  const meta: Record<string, string> = {};
  for (const line of m[1].split("\n")) {
    const kv = line.match(/^([a-z-]+):\s*(.+)$/);
    if (kv) meta[kv[1]] = kv[2].trim().replace(/^"(.*)"$/, "$1");
  }
  return { meta, body: m[2].trim() };
}

function label(
  tool: string,
  file: string,
  ok: boolean,
  detail?: string,
): void {
  const mark = ok ? "✓" : "✗";
  const suffix = detail ? ` (${detail})` : "";
  console.log(`  ${mark} home/${tool}/${file}${suffix}`);
}

// ============================================================
// Instructions Sync: CLAUDE.md + rules -> AGENTS.md / GEMINI.md
// ============================================================

async function syncInstructions(check: boolean): Promise<boolean> {
  console.log("Syncing instructions...");

  const claudeMd = (await readText(join(home.claude, "CLAUDE.md"))).trim();

  const ruleParts: string[] = [];
  for (const p of SHARED_RULES) {
    ruleParts.push((await readText(join(home.claude, "rules", p))).trim());
  }

  const rulesJoined = ruleParts.join("\n\n");
  const body = [GENERATED_MD, "", claudeMd, "", rulesJoined, ""].join("\n");

  let allOk = true;
  const targets: [string, string][] = [
    ["codex", "AGENTS.md"],
    ["gemini", "GEMINI.md"],
  ];

  for (const [tool, file] of targets) {
    const target = join(home[tool as keyof typeof home], file);
    const ok = await writeIfChanged(target, body, check);
    label(tool, file, ok, ok ? (check ? "up to date" : undefined) : "out of date");
    if (!ok) allOk = false;
  }

  return allOk;
}

// ============================================================
// Skills Sync: Verify/create symlinks
// ============================================================

async function syncSkills(check: boolean): Promise<boolean> {
  console.log("Syncing skills...");

  let allOk = true;

  for (const tool of ["codex", "gemini"] as const) {
    const skillsDir = join(home[tool], "skills");
    if (!check) {
      await Deno.mkdir(skillsDir, { recursive: true });
    }

    for (const skill of SHARED_SKILLS) {
      const linkPath = join(skillsDir, skill);
      const target = join("..", "..", "claude", "skills", skill);

      try {
        const existing = await Deno.readLink(linkPath);
        if (existing === target) {
          label(tool, `skills/${skill}`, true, "ok");
          continue;
        }
        // Wrong target
        if (!check) {
          await Deno.remove(linkPath, { recursive: true });
        }
      } catch {
        // Doesn't exist
      }

      if (check) {
        label(tool, `skills/${skill}`, false, "missing or wrong target");
        allOk = false;
      } else {
        await Deno.symlink(target, linkPath);
        label(tool, `skills/${skill}`, true, "created");
      }
    }
  }

  return allOk;
}

// ============================================================
// MCP Sync: mcp.json -> config.toml / settings.json
// ============================================================

interface McpServer {
  command?: string;
  args?: string[];
  env?: Record<string, string>;
  type?: string;
  url?: string;
}

function mcpToToml(servers: Record<string, McpServer>): string {
  const sections: string[] = [];

  for (const [name, cfg] of Object.entries(servers)) {
    const lines: string[] = [`[mcp_servers.${name}]`];

    if (cfg.type === "http" || (cfg.url && !cfg.command)) {
      lines.push(`url = ${JSON.stringify(cfg.url)}`);
    } else {
      if (cfg.command) lines.push(`command = ${JSON.stringify(cfg.command)}`);
      if (cfg.args) lines.push(`args = ${JSON.stringify(cfg.args)}`);
    }

    if (cfg.env) {
      lines.push("");
      lines.push(`[mcp_servers.${name}.env]`);
      for (const [k, v] of Object.entries(cfg.env)) {
        lines.push(`${k} = ${JSON.stringify(v)}`);
      }
    }

    sections.push(lines.join("\n"));
  }

  return sections.join("\n\n") + "\n";
}

function mcpToGeminiJson(
  servers: Record<string, McpServer>,
): Record<string, unknown> {
  const result: Record<string, unknown> = {};

  for (const [name, cfg] of Object.entries(servers)) {
    const entry: Record<string, unknown> = {};

    if (cfg.type === "http" || (cfg.url && !cfg.command)) {
      entry.httpUrl = cfg.url;
    } else {
      if (cfg.command) entry.command = cfg.command;
      if (cfg.args) entry.args = cfg.args;
    }

    if (cfg.env) entry.env = cfg.env;
    result[name] = entry;
  }

  return result;
}

async function syncMcp(check: boolean): Promise<boolean> {
  console.log("Syncing MCP servers...");

  const mcpJson = JSON.parse(await readText(join(home.claude, "mcp.json")));
  const servers: Record<string, McpServer> = mcpJson.mcpServers ?? {};

  let allOk = true;

  // --- Codex: append [mcp_servers.*] to config.toml ---
  {
    const raw = await readText(join(home.codex, "config.toml"));

    // Strip existing auto-generated MCP section (from marker to EOF or next non-mcp section)
    const marker = "# AUTO-GENERATED by sync-tools.ts from home/claude/mcp.json";
    const markerIdx = raw.indexOf(marker);
    const base = markerIdx >= 0
      ? raw.substring(0, markerIdx).trimEnd()
      : raw.trimEnd();

    const newContent = base + "\n\n" + marker + "\n" + mcpToToml(servers);

    const ok = await writeIfChanged(
      join(home.codex, "config.toml"),
      newContent,
      check,
    );
    label("codex", "config.toml", ok, ok ? "mcp_servers" : "out of date");
    if (!ok) allOk = false;
  }

  // --- Gemini: merge mcpServers into settings.json ---
  {
    const settings = JSON.parse(
      await readText(join(home.gemini, "settings.json")),
    );
    settings.mcpServers = mcpToGeminiJson(servers);
    const newContent = JSON.stringify(settings, null, 2) + "\n";

    const ok = await writeIfChanged(
      join(home.gemini, "settings.json"),
      newContent,
      check,
    );
    label("gemini", "settings.json", ok, ok ? "mcpServers" : "out of date");
    if (!ok) allOk = false;
  }

  return allOk;
}

// ============================================================
// Commands Sync: Claude Markdown -> Gemini TOML
// ============================================================

function stripClaudeSections(body: string): string {
  const lines = body.split("\n");
  const result: string[] = [];
  let skipping = false;
  let skipLevel = 0;

  for (const line of lines) {
    const heading = line.match(/^(#{1,4})\s+(.*)$/);

    if (heading) {
      const level = heading[1].length;
      const title = heading[2].trim();

      // Skip Claude-specific sections
      if (/^(Language|Tool Restrictions)/.test(title)) {
        skipping = true;
        skipLevel = level;
        continue;
      }

      // End skip when reaching same or higher level heading
      if (skipping && level <= skipLevel) {
        skipping = false;
      }
    }

    if (!skipping) {
      result.push(line);
    }
  }

  return result
    .join("\n")
    // Replace Task tool delegation with direct instructions
    .replace(
      /Use the Task tool \(`subagent_type: "[^"]+"`?\) to /g,
      "",
    )
    .replace(
      /use the Task tool \(`subagent_type: "[^"]+"`?\) to /g,
      "",
    )
    // Clean up double blank lines
    .replace(/\n{3,}/g, "\n\n")
    .trim();
}

function toGeminiToml(description: string, prompt: string): string {
  // Escape triple quotes in prompt if present
  const safePrompt = prompt.replace(/"""/g, '"""');
  return `${GENERATED_TOML}\n` +
    `description = ${JSON.stringify(description)}\n` +
    `prompt = """\n${safePrompt}\n"""\n`;
}

async function syncCommands(check: boolean): Promise<boolean> {
  console.log("Syncing commands...");

  let allOk = true;

  for (const cmdPath of COMMANDS_TO_CONVERT) {
    const claudeFile = join(home.claude, "commands", `${cmdPath}.md`);
    const geminiFile = join(home.gemini, "commands", `${cmdPath}.toml`);

    const content = await readText(claudeFile);
    const { meta, body } = parseFrontmatter(content);
    const description = meta.description ?? cmdPath;
    const cleanedBody = stripClaudeSections(body);
    const toml = toGeminiToml(description, cleanedBody);

    const ok = await writeIfChanged(geminiFile, toml, check);
    label("gemini", `commands/${cmdPath}.toml`, ok, ok ? undefined : "out of date");
    if (!ok) allOk = false;
  }

  return allOk;
}

// ============================================================
// Main
// ============================================================

type SyncFn = (check: boolean) => Promise<boolean>;

const SYNC_ALL: [string, SyncFn][] = [
  ["instructions", syncInstructions],
  ["skills", syncSkills],
  ["mcp", syncMcp],
  ["commands", syncCommands],
];

async function main(): Promise<void> {
  const args = Deno.args;
  const check = args.includes("--check");
  const sub = args.find((a) => !a.startsWith("-")) ?? "all";

  const tasks: [string, SyncFn][] = sub === "all"
    ? SYNC_ALL
    : SYNC_ALL.filter(([name]) => name === sub);

  if (tasks.length === 0) {
    console.error(`Unknown subcommand: ${sub}`);
    console.error("Usage: sync-tools.ts [instructions|skills|mcp|commands|all] [--check]");
    Deno.exit(1);
  }

  let allOk = true;
  for (const [, fn] of tasks) {
    const ok = await fn(check);
    if (!ok) allOk = false;
  }

  if (check && !allOk) {
    console.log("\nSync is out of date. Run: deno task sync");
    Deno.exit(1);
  }

  if (!check) {
    console.log("\nDone.");
  }
}

if (import.meta.main) {
  main();
}
