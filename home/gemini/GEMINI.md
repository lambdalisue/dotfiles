<!-- AUTO-GENERATED by .scripts/sync-tools.ts from home/claude/ -->
<!-- Do not edit directly. Run: deno task sync -->

# CORE PRINCIPLES

- Follow Kent Beck's TDD methodology
- Document at the right layer: Code → How, Tests → What, Commits → Why, Comments → Why not

## Workflow

- ALWAYS check for matching Skills before manual implementation
- Provide Task tool prompts in English; communicate with user in **Japanese** (including Plan mode output)
- **Written artifacts** (commit messages, PR titles/bodies, Issue titles/bodies, branch names): preserve the original language as-is — do NOT translate them to match the conversation language
- When compacting, preserve: modified file list, test commands, architectural decisions

## Codebase Investigation

- When investigating an external Git-managed codebase, clone it to `/tmp` and explore local files using Grep/Glob/Read tools
- Do NOT rely on WebFetch or GitHub API for code exploration — always prefer local clone

## Language Convention for Code Output

- If the repository path contains `attmcojp`, write all comments, log messages, and error messages in **Japanese** unless otherwise instructed
- For all other repositories, write all comments, log messages, and error messages in **English** unless otherwise instructed

# Git Safety Rules

## Commit Restriction

**ABSOLUTELY NEVER COMMIT WITHOUT EXPLICIT USER PERMISSION.**

- MUST use AskUserQuestion before ANY commit operation
- Permission valid for ONE commit only
- ONLY commit when user explicitly says "commit" in CURRENT message
- Show what will be committed and ask final confirmation

**NEVER run `git commit` directly via the Bash tool.** All commits MUST go through:
- `/git:commit` — analyze working tree and create atomic commits
- `/git:commit-staged` — commit already-staged changes

This applies to the main orchestrator AND any manual commit attempts.
Direct `git add ... && git commit` or `git commit -m "..."` via Bash is **PROHIBITED**.

## Backup Before Destructive Operations

ALWAYS backup before: `git restore`, `git reset`, `git checkout` (with uncommitted changes), file deletion of uncommitted work.

## Git Stash Forbidden

**NEVER use `git stash`** (shared across worktrees → contamination). Use backup branch instead.

## Stay in Worktree Directory

If starting in `.worktrees/{branch}/`, ALL operations stay there. Use absolute paths to check root state.

# Git Commit Safety Rules

## Forbidden Staging Commands

**ABSOLUTELY NEVER use these commands in ANY commit workflow:**

- `git add -A` — stages ALL files including untracked (dangerous: may include .env, credentials, large binaries)
- `git add .` — stages all in current directory (dangerous: same risks as `-A`)
- `git commit -a` / `git commit --all` — auto-stages all modified files (dangerous: bypasses explicit staging)

## Safe Staging Practice

**ALWAYS stage files explicitly by name:**

```bash
# Good: Explicit file staging
git add src/parser.ts
git add tests/parser.test.ts

# Bad: Bulk staging
git add -A          # FORBIDDEN
git add .           # FORBIDDEN
git commit -a       # FORBIDDEN
```

## Why This Matters

1. **Security**: Prevents accidental commit of `.env`, API keys, credentials
2. **Intent**: Forces conscious decision about what to commit
3. **Review**: Makes it easier to review staged changes before committing
4. **Hygiene**: Prevents large binaries or build artifacts from entering git history

## Enforcement

- All git commit agents and skills MUST verify staging before committing
- Agents MUST use `git commit -m "<message>"` (never `git commit -a`)
- If nothing is staged, agents MUST report error and stop (never auto-stage)
- Commands MUST validate staging status before invoking agents

## Related Rules

See also:
- `rules/git/safety.md` — General git safety (backup, stash, destructive operations)
- `agents/git-commit-staged.md` — Commit agent restrictions
- `commands/git/commit-staged.md` — Commit command workflow

# Set Issue Type on GitHub Issue Creation

When creating a GitHub Issue with `gh issue create`, always set the issue type afterward using the REST API:

```bash
gh api -X PATCH repos/{owner}/{repo}/issues/{number} --field type={type}
```

Determine the appropriate type (e.g., `Feature`, `Bug`) from the issue content and set it immediately after creation.
